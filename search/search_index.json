{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lmo","text":"<p>Lmo is a lightweight library with pythonic syntax. Some features include:</p> <ul> <li>Lightweight; it only requires numpy</li> <li>Clean code style: linted with ruff</li> <li>Fully type-annotated, valid in pyright's strict mode.</li> <li>Hypothesis-tested</li> <li>Flat functions, no classes (scipy &gt; scikit) </li> <li>Red and fluffy</li> </ul>"},{"location":"#why-tl-moments","title":"Why (T)L-moments?","text":"<p>Coming soon. For now, see Wikipedia</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Sample L-, and TL-moment estimators</li> <li> Multivariate L- and TL- co-moments.</li> <li> Standard error / covariance matrices of the sample (T)L-moments (Elamir et al. 2002, 4.1.)</li> <li> Parameter estimatation for known probability distributions.</li> <li> Better docs: introduction, motivation, examples, etc.</li> <li> Numerical tools for estimating (T)L-moments of unknown distributions.</li> <li> Optional numba JIT support.</li> <li> Generic (T)L method-of-moments implementation</li> <li> LQ-moments (Mudholkar and Hutson, 1998)</li> </ul>"},{"location":"contributing/","title":"Contributing to lmo","text":"<p>Any contributions to lmo are appreciated!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues.</p> <p>When reporting a bug, make sure to include the versions of <code>lmo</code>, <code>python</code> and <code>numpy</code> you are using, and provide a reproducable example of the bug.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Ensure you have poetry installed, then</p> <pre><code>poetry install\n</code></pre>"},{"location":"reference/","title":"Documentation for <code>lmo</code>","text":"<p>Estimators of the sample L-moments, and derived summary statistics.</p> <p>According to Wikipedia:</p> <p>L-moments are far more meaningful when dealing with outliers in data than conventional moments.</p> <p>Note that L-moments are robust to outliers, but not resistant to extreme values.</p> <p>Often the Method of L-moment (LMM) outperforms the conventional method of moments (MM) and maximum likelihood estimation (MLE), e.g. ftting of the <code>scipy.stats.genextreme</code> (generalized extreme value, GED) distribution.</p> See Also <ul> <li>J.R.M. Hosking (1990) - L-Moments: Analysis and Estimation of   Distributions Using Linear Combinations of   Order Statistics</li> <li>E. Elmamir &amp; A. Seheult (2003) -   Trimmed L-moments</li> <li>J.R.M. Hosking (2007) - Some theory and practical uses of trimmed   L-moments</li> </ul>"},{"location":"reference/#lmo.univariate.tl_moment","title":"<code>tl_moment(a, r, /, s=1, t=1, *, axis=None, sort=None)</code>","text":"<p>The r-th sample TL-moment.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>npt.ArrayLike</code> <p>Array-like with samples.</p> required <code>r</code> <code>int</code> <p>The order of the TL-moment; strictly positive integer.</p> required <code>s</code> <code>int</code> <p>Amount of samples to trim at the start, default is 1.</p> <code>1</code> <code>t</code> <code>int</code> <p>Amount of samples to trim at the end, default is 1.</p> <code>1</code> <code>axis</code> <code>int | None</code> <p>Axis along wich to calculate the TL-moments. If <code>None</code> (default), all samples in the array will be used.</p> <code>None</code> <code>sort</code> <code>SortKind | None</code> <p>Sorting algorithm to use, default is <code>'quicksort'</code>. See <code>numpy.sort</code> for more info.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.float_ | npt.NDArray[np.float_]</code> <p>Scalar or array; the r-th TL-moment(s).</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_moment(\n    a: npt.ArrayLike,\n    r: int,\n    /,\n    s: int = 1,\n    t: int = 1,\n    *,\n    axis: int | None = None,\n    sort: SortKind | None = None,\n) -&gt; np.float_ | npt.NDArray[np.float_]:\n\"\"\"\n    The r-th sample TL-moment.\n\n    Args:\n        a: Array-like with samples.\n        r: The order of the TL-moment; strictly positive integer.\n\n        s: Amount of samples to trim at the start, default is 1.\n        t: Amount of samples to trim at the end, default is 1.\n\n        axis: Axis along wich to calculate the TL-moments.\n            If `None` (default), all samples in the array will be used.\n        sort: Sorting algorithm to use, default is `'quicksort'`. See\n            `numpy.sort` for more info.\n\n    Returns:\n        Scalar or array; the r-th TL-moment(s).\n\n    \"\"\"\n    x = np.sort(a, axis=axis, kind=sort)\n    n = x.shape[axis or 0]\n\n    if r == 0:\n        # zeroth (TL-)moment is 1\n        # noinspection PyTypeChecker\n        dt: np.dtype[_AnyFloat] = np.find_common_type([x.dtype], [np.float_])\n        return np.ones(x.size // n, dtype=dt) if x.ndim &gt; 1 else dt.type(1)\n\n    w = tl_weights(n, r, s, t)\n\n    _axis = (axis or 0) % x.ndim\n    assert _axis &gt;= 0\n\n    if _axis == 0:\n        # apply along the first axis\n        return w @ x\n\n    if x.ndim == 2 or _axis == x.ndim - 1:\n        # apply along the last axis\n        return x @ w\n\n    return np.apply_along_axis(np.inner, _axis, x, w)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_ratio","title":"<code>tl_ratio(a, r, /, k=2, s=1, t=1, *, axis=None, sort=None)</code>","text":"<p>Ratio of the r-th and k-th (2nd by default) sample TL-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_ratio(\n    a: npt.ArrayLike,\n    r: int,\n    /,\n    k: int = 2,\n    s: int = 1,\n    t: int = 1,\n    *,\n    axis: int | None = None,\n    sort: SortKind | None = None,\n) -&gt; _NumOrArr:\n\"\"\"\n    Ratio of the r-th and k-th (2nd by default) sample TL-moments.\n    \"\"\"\n    x = np.sort(a, axis=axis, kind=sort)\n\n    l_r = tl_moment(x, r, s, t, axis=axis)\n\n    if k == 0:\n        return l_r\n    if k == r:\n        return np.ones_like(l_r)\n\n    l_k = l_r if k == r else tl_moment(x, k, s, t, axis=axis)\n\n    if not l_k:\n        # respect the bounds; use nan instead of inf\n        return np.nan * l_r if l_r else l_r\n    return l_r / l_k\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_loc","title":"<code>tl_loc(a, /, s=1, t=1, **kwargs)</code>","text":"<p>TL-location: the first sample TL-moment. Analogous to the sample mean.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_loc(\n    a: npt.ArrayLike,\n    /,\n    s: int = 1,\n    t: int = 1,\n    **kwargs: Any,\n) -&gt; _NumOrArr:\n\"\"\"\n    TL-location: the first sample TL-moment. Analogous to the sample mean.\n    \"\"\"\n    return tl_moment(a, 1, s, t, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_scale","title":"<code>tl_scale(a, /, s=1, t=1, **kwargs)</code>","text":"<p>TL-scale: the second TL-moment. Analogous to the sample standard deviation.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_scale(\n    a: npt.ArrayLike,\n    /,\n    s: int = 1,\n    t: int = 1,\n    **kwargs: Any,\n) -&gt; _NumOrArr:\n\"\"\"\n    TL-scale: the second TL-moment. Analogous to the sample standard deviation.\n    \"\"\"\n    return tl_moment(a, 2, s, t, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_skew","title":"<code>tl_skew(a, /, s=1, t=1, **kwargs)</code>","text":"<p>TL-skewness coefficient; the ratio of the 3rd and 2nd sample TL-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_skew(\n    a: npt.ArrayLike,\n    /,\n    s: int = 1,\n    t: int = 1,\n    **kwargs: Any,\n) -&gt; _NumOrArr:\n\"\"\"\n    TL-skewness coefficient; the ratio of the 3rd and 2nd sample TL-moments.\n    \"\"\"\n    return tl_ratio(a, 3, s=s, t=t, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_kurt","title":"<code>tl_kurt(a, /, s=1, t=1, **kwargs)</code>","text":"<p>TL-kurtosis coefficient; the ratio of the 4th and 2nd sample TL-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_kurt(\n    a: npt.ArrayLike,\n    /,\n    s: int = 1,\n    t: int = 1,\n    **kwargs: Any,\n) -&gt; _NumOrArr:\n\"\"\"\n    TL-kurtosis coefficient; the ratio of the 4th and 2nd sample TL-moments.\n    \"\"\"\n    return tl_ratio(a, 4, s=s, t=t, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_moment","title":"<code>l_moment(a, r, /, **kwargs)</code>","text":"<p>The r-th sample L-moment. Alias for <code>tl_moment(a, r, 0, 0, **kwargs)</code>.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_moment(a: npt.ArrayLike, r: int, /, **kwargs: Any) -&gt; _NumOrArr:\n\"\"\"\n    The r-th sample L-moment.\n    Alias for ``tl_moment(a, r, 0, 0, **kwargs)``.\n    \"\"\"\n    return tl_moment(a, r, 0, 0, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_ratio","title":"<code>l_ratio(a, r, k=2, /, **kwargs)</code>","text":"<p>Ratio of the r-th and k-th L-moments. Alias for <code>tl_ratio(a, r, k, 0, 0, **kwargs)</code>.</p> <p>For k &gt; 0, the L-moment ratio's are bounded within [-1, 1].</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_ratio(\n    a: npt.ArrayLike,\n    r: int, k: int = 2,\n    /,\n    **kwargs: Any,\n) -&gt; _NumOrArr:\n\"\"\"\n    Ratio of the r-th and k-th L-moments.\n    Alias for ``tl_ratio(a, r, k, 0, 0, **kwargs)``.\n\n    For k &gt; 0, the L-moment ratio's are bounded within [-1, 1].\n    \"\"\"\n    return tl_ratio(a, r, k, 0, 0, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_loc","title":"<code>l_loc(a, /, **kwargs)</code>","text":"<p>L-location: the first sample L-moment. Equivalent to the sample mean.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_loc(a: npt.ArrayLike, /, **kwargs: Any) -&gt; _NumOrArr:\n\"\"\"\n    L-location: the first sample L-moment.\n    Equivalent to the sample mean.\n    \"\"\"\n    return l_moment(a, 1, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_scale","title":"<code>l_scale(a, /, **kwargs)</code>","text":"<p>L-scale: the second L-moment. Equivalent to half the mean absolute difference.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_scale(a: npt.ArrayLike, /, **kwargs: Any) -&gt; _NumOrArr:\n\"\"\"\n    L-scale: the second L-moment.\n    Equivalent to half the mean absolute difference.\n    \"\"\"\n    return l_moment(a, 2, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_skew","title":"<code>l_skew(a, /, **kwargs)</code>","text":"<p>L-skewness coefficient; the ratio of the 3rd and 2nd sample L-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_skew(a: npt.ArrayLike, /, **kwargs: Any) -&gt; _NumOrArr:\n\"\"\"\n    L-skewness coefficient; the ratio of the 3rd and 2nd sample L-moments.\n    \"\"\"\n    return l_ratio(a, 3, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_kurt","title":"<code>l_kurt(a, /, **kwargs)</code>","text":"<p>L-kurtosis coefficient; the ratio of the 4th and 2nd sample L-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_kurt(a: npt.ArrayLike, /, **kwargs: Any) -&gt; _NumOrArr:\n\"\"\"\n    L-kurtosis coefficient; the ratio of the 4th and 2nd sample L-moments.\n    \"\"\"\n    return l_ratio(a, 4, **kwargs)\n</code></pre>"}]}