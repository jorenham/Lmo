{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lmo","text":"<p>Lmo is a lightweight library with pythonic syntax. Some features include:</p> <ul> <li>Lightweight; it only requires numpy</li> <li>Clean code style: linted with ruff</li> <li>Fully type-annotated, valid in pyright's strict mode.</li> <li>Hypothesis-tested</li> <li>Flat functions, no classes (scipy &gt; scikit) </li> <li>Red and fluffy</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install lmo\n</code></pre>"},{"location":"#why-tl-moments","title":"Why (T)L-moments?","text":"<p>Coming soon. For now, see Wikipedia</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Sample L-, and TL-moment estimators</li> <li> Sample L- and TL- co-moments (multivariate) estimators</li> <li> Variance structure of sample (T)L moments #4</li> <li> Fitting of distributions with known TL- or L-moments #5</li> <li> Population (T)L-moment estimation from quantile functions #6</li> </ul>"},{"location":"contributing/","title":"Contributing to lmo","text":"<p>Any contributions to lmo are appreciated!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues.</p> <p>When reporting a bug, make sure to include the versions of <code>lmo</code>, <code>python</code> and <code>numpy</code> you are using, and provide a reproducable example of the bug.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Ensure you have poetry installed, then</p> <pre><code>poetry install\n</code></pre>"},{"location":"reference/","title":"Documentation for <code>lmo</code>","text":"<p>Estimators of the sample L-moments, and derived summary statistics.</p> <p>According to Wikipedia:</p> <p>L-moments are far more meaningful when dealing with outliers in data than conventional moments.</p> <p>Note that L-moments are robust to outliers, but not resistant to extreme values.</p> <p>Often the Method of L-moment (LMM) outperforms the conventional method of moments (MM) and maximum likelihood estimation (MLE), e.g. ftting of the <code>scipy.stats.genextreme</code> (generalized extreme value, GED) distribution.</p> See Also <ul> <li>J.R.M. Hosking (1990) - L-Moments: Analysis and Estimation of   Distributions Using Linear Combinations of   Order Statistics</li> <li>E. Elmamir &amp; A. Seheult (2003) -   Trimmed L-moments</li> <li>J.R.M. Hosking (2007) - Some theory and practical uses of trimmed   L-moments</li> </ul>"},{"location":"reference/#lmo.univariate.tl_moment","title":"<code>tl_moment(a, r, /, trim=1, *, axis=None, sort=None)</code>","text":"<p>The r-th sample TL-moment.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>AnyTensor</code> <p>Array-like with samples.</p> required <code>r</code> <code>int</code> <p>The order of the TL-moment; strictly positive integer.</p> required <code>trim</code> <code>Trimming</code> <p>Amount of samples to trim on both sides, or a tuple of the amount to trim on the left and right sides.</p> <code>1</code> <code>axis</code> <code>int | None</code> <p>Axis along wich to calculate the TL-moments. If <code>None</code> (default), all samples in the array will be used.</p> <code>None</code> <code>sort</code> <code>SortKind | None</code> <p>Sorting algorithm to use, default is <code>'quicksort'</code>. See <code>numpy.sort</code> for more info.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarOrArray[np.float_]</code> <p>Scalar or array; the r-th TL-moment(s).</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_moment(\n    a: AnyTensor,\n    r: int,\n    /,\n    trim: Trimming = 1,\n    *,\n    axis: int | None = None,\n    sort: SortKind | None = None,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    The r-th sample TL-moment.\n\n    Args:\n        a: Array-like with samples.\n        r: The order of the TL-moment; strictly positive integer.\n        trim: Amount of samples to trim on both sides, or a tuple of the amount\n            to trim on the left and right sides.\n\n        axis: Axis along wich to calculate the TL-moments.\n            If `None` (default), all samples in the array will be used.\n        sort: Sorting algorithm to use, default is `'quicksort'`. See\n            `numpy.sort` for more info.\n\n    Returns:\n        Scalar or array; the r-th TL-moment(s).\n\n    \"\"\"\n    x = np.sort(np.asanyarray(a), axis=axis, kind=sort)\n    n = x.shape[axis or 0]\n\n    if r == 0:\n        # zeroth (TL-)moment is 1\n        return np.ones(x.size // n) if x.ndim &gt; 1 else np.float_(1)\n\n    w = tl_weights(n, r, trim)\n\n    _axis = (axis or 0) % x.ndim\n    assert _axis &gt;= 0\n\n    if _axis == 0:\n        # apply along the first axis\n        return w @ x\n\n    if x.ndim == 2 or _axis == x.ndim - 1:\n        # apply along the last axis\n        return x @ w\n\n    return np.apply_along_axis(np.inner, _axis, x, w)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_ratio","title":"<code>tl_ratio(a, r, /, k=2, trim=1, *, axis=None, sort=None)</code>","text":"<p>Ratio of the r-th and k-th (2nd by default) sample TL-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_ratio(\n    a: AnyTensor,\n    r: int,\n    /,\n    k: int = 2,\n    trim: Trimming = 1,\n    *,\n    axis: int | None = None,\n    sort: SortKind | None = None,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    Ratio of the r-th and k-th (2nd by default) sample TL-moments.\n    \"\"\"\n    x = np.sort(np.asanyarray(a), axis=axis, kind=sort)\n\n    l_r = tl_moment(x, r, trim, axis=axis)\n\n    if k == 0:\n        return l_r\n    if k == r:\n        return np.ones_like(l_r)[()]\n\n    l_k = l_r if k == r else tl_moment(x, k, trim, axis=axis)\n\n    # i.e. `x / 0 = 0 if x == 0 else np.nan`\n    return np.divide(\n        l_r,\n        l_k,\n        out=np.where(l_r == 0, 0.0, np.nan),\n        where=l_k != 0\n    )[()]  # [()] converts any 0-dimensional arrays to scalar\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_loc","title":"<code>tl_loc(a, /, trim=1, **kwargs)</code>","text":"<p>TL-location: the first sample TL-moment. Analogous to the sample mean.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_loc(\n    a: AnyTensor,\n    /,\n    trim: Trimming = 1,\n    **kwargs: Any,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    TL-location: the first sample TL-moment. Analogous to the sample mean.\n    \"\"\"\n    return tl_moment(a, 1, trim, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_scale","title":"<code>tl_scale(a, /, trim=1, **kwargs)</code>","text":"<p>TL-scale: the second TL-moment. Analogous to the sample standard deviation.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_scale(\n    a: AnyTensor,\n    /,\n    trim: Trimming = 1,\n    **kwargs: Any,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    TL-scale: the second TL-moment. Analogous to the sample standard deviation.\n    \"\"\"\n    return tl_moment(a, 2, trim, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_skew","title":"<code>tl_skew(a, /, trim=1, **kwargs)</code>","text":"<p>TL-skewness coefficient; the ratio of the 3rd and 2nd sample TL-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_skew(\n    a: AnyTensor,\n    /,\n    trim: Trimming = 1,\n    **kwargs: Any,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    TL-skewness coefficient; the ratio of the 3rd and 2nd sample TL-moments.\n    \"\"\"\n    return tl_ratio(a, 3, trim=trim, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.tl_kurt","title":"<code>tl_kurt(a, /, trim=1, **kwargs)</code>","text":"<p>TL-kurtosis coefficient; the ratio of the 4th and 2nd sample TL-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def tl_kurt(\n    a: AnyTensor,\n    /,\n    trim: Trimming = 1,\n    **kwargs: Any,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    TL-kurtosis coefficient; the ratio of the 4th and 2nd sample TL-moments.\n    \"\"\"\n    return tl_ratio(a, 4, trim=trim, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_moment","title":"<code>l_moment(a, r, /, **kwargs)</code>","text":"<p>The r-th sample L-moment. Alias for <code>tl_moment(a, r, 0, **kwargs)</code>.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_moment(\n    a: AnyTensor,\n    r: int,\n    /,\n    **kwargs: Any,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    The r-th sample L-moment.\n    Alias for ``tl_moment(a, r, 0, **kwargs)``.\n    \"\"\"\n    return tl_moment(a, r, 0, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_ratio","title":"<code>l_ratio(a, r, k=2, /, **kwargs)</code>","text":"<p>Ratio of the r-th and k-th L-moments. Alias for <code>tl_ratio(a, r, k, 0, **kwargs)</code>.</p> <p>For k &gt; 0, the L-moment ratio's are bounded within [-1, 1].</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_ratio(\n    a: AnyTensor,\n    r: int,\n    k: int = 2,\n    /,\n    **kwargs: Any,\n) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    Ratio of the r-th and k-th L-moments.\n    Alias for ``tl_ratio(a, r, k, 0, **kwargs)``.\n\n    For k &gt; 0, the L-moment ratio's are bounded within [-1, 1].\n    \"\"\"\n    return tl_ratio(a, r, k, 0, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_loc","title":"<code>l_loc(a, /, **kwargs)</code>","text":"<p>L-location: the first sample L-moment. Equivalent to the sample mean.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_loc(a: AnyTensor, /, **kwargs: Any) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    L-location: the first sample L-moment.\n    Equivalent to the sample mean.\n    \"\"\"\n    return l_moment(a, 1, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_scale","title":"<code>l_scale(a, /, **kwargs)</code>","text":"<p>L-scale: the second L-moment. Equivalent to half the mean absolute difference.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_scale(a: AnyTensor, /, **kwargs: Any) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    L-scale: the second L-moment.\n    Equivalent to half the mean absolute difference.\n    \"\"\"\n    return l_moment(a, 2, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_skew","title":"<code>l_skew(a, /, **kwargs)</code>","text":"<p>L-skewness coefficient; the ratio of the 3rd and 2nd sample L-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_skew(a: AnyTensor, /, **kwargs: Any) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    L-skewness coefficient; the ratio of the 3rd and 2nd sample L-moments.\n    \"\"\"\n    return l_ratio(a, 3, **kwargs)\n</code></pre>"},{"location":"reference/#lmo.univariate.l_kurt","title":"<code>l_kurt(a, /, **kwargs)</code>","text":"<p>L-kurtosis coefficient; the ratio of the 4th and 2nd sample L-moments.</p> Source code in <code>lmo/univariate.py</code> <pre><code>def l_kurt(a: AnyTensor, /, **kwargs: Any) -&gt; ScalarOrArray[np.float_]:\n\"\"\"\n    L-kurtosis coefficient; the ratio of the 4th and 2nd sample L-moments.\n    \"\"\"\n    return l_ratio(a, 4, **kwargs)\n</code></pre>"}]}