{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#lmo","title":"Lmo","text":"<p>Generalized trimmed L-moments for robust statistics. </p> <p>Lmo is a lightweight library with pythonic syntax. Some features include:</p> <ul> <li>Robust alternatives to conventional moments: even the Cauchy distribution poses no threat!</li> <li>Handles both univariate and multivariate cases</li> <li>Support for custom sample weights</li> <li>Lightweight; it only requires numpy</li> <li>Scales to millions of samples, with \\(O(n \\\\log(n))\\) time-complexity and \\(O(n)\\) space-complexity. </li> <li>Clean code style: linted with ruff, and valid in pyright's strict mode</li> <li>Thoroughly tested with hypothesis</li> <li>Red and fluffy</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install lmo\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Sample L-, and TL-moment estimators</li> <li> Sample L- and TL- co-moments (multivariate) estimators</li> <li> Support for observation weights.</li> <li> Variance structure of sample (T)L moments #4</li> <li> Fitting of distributions with known TL- or L-moments #5</li> <li> Population (T)L-moment estimation from quantile functions #6</li> </ul>"},{"location":"contributing/","title":"Contributing to lmo","text":"<p>Any contributions to lmo are appreciated!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues.</p> <p>When reporting a bug, make sure to include the versions of <code>lmo</code>, <code>python</code> and <code>numpy</code> you are using, and provide a reproducable example of the bug.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Ensure you have poetry installed, then</p> <pre><code>poetry install\n</code></pre>"},{"location":"reference/","title":"Lmo reference","text":""},{"location":"reference/#univariate","title":"Univariate","text":""},{"location":"reference/#lmo.l_moment","title":"<code>lmo.l_moment(a, r, /, trim=(0, 0), axis=None, dtype=np.float_, *, fweights=None, aweights=None, sort='stable')</code>","text":"<p>Estimates the generalized trimmed L-moment \\(\\lambda^{(t_1, t_2)}_r\\) from the samples along the specified axis. By default, this will be the regular L-moment, \\(\\lambda_r = \\lambda^{(0, 0)}_r\\).</p> PARAMETER DESCRIPTION <code>a</code> <p>Array containing numbers whose L-moments is desired. If <code>a</code> is not an array, a conversion is attempted.</p> <p> TYPE: <code>npt.ArrayLike</code> </p> <code>r</code> <p>The L-moment order(s), non-negative integer or array.</p> <p> TYPE: <code>AnyInt | IntVector</code> </p> <code>trim</code> <p>Left- and right-trim orders \\((t_1, t_2)\\), non-negative integers that are bound by \\(t_1 + t_2 &lt; n - r\\).</p> <p>Some special cases include:</p> <ul> <li>\\((0, 0)\\): The original L-moment, introduced by Hosking (1990).     Useful for fitting the e.g. log-normal and generalized extreme     value (GEV) distributions.</li> <li>\\((0, m)\\): LL-moment (Linear combination of Lowest     order statistics), instroduced by Bayazit &amp; Onoz (2002).     Assigns more weight to smaller observations.</li> <li>\\((s, 0)\\): LH-moment (Linear combination of Higher     order statistics), by Wang (1997).     Assigns more weight to larger observations.</li> <li>\\((t, t)\\): TL-moment (Trimmed L-moment) \\(\\lambda_r^t\\),     with symmetric trimming. First introduced by     Elamir &amp; Seheult (2003).     Generally more robust than L-moments.     Useful for fitting heavy-tailed distributions, such as the     Cauchy distribution.</li> </ul> <p> TYPE: <code>tuple[int, int]</code> DEFAULT: <code>(0, 0)</code> </p> <code>axis</code> <p>Axis along wich to calculate the moments. If <code>None</code> (default), all samples in the array will be used.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>dtype</code> <p>Floating type to use in computing the L-moments. Default is <code>numpy.float64</code>.</p> <p> TYPE: <code>np.dtype[T] | type[T]</code> DEFAULT: <code>np.float_</code> </p> <code>fweights</code> <p>1-D array of integer frequency weights; the number of times each observation vector should be repeated.</p> <p> TYPE: <code>IntVector | None</code> DEFAULT: <code>None</code> </p> <code>aweights</code> <p>An array of weights associated with the values in <code>a</code>. Each value in <code>a</code> contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of a along the given axis) or of the same shape as <code>a</code>. If <code>aweights=None</code> (default), then all data in <code>a</code> are assumed to have a weight equal to one.</p> <p>All <code>aweights</code> must be <code>&gt;=0</code>, and the sum must be nonzero.</p> <p>The algorithm is similar to that for weighted quantiles.</p> <p> TYPE: <code>npt.ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p>Sorting algorithm, see <code>numpy.sort</code>.</p> <p> TYPE: <code>quick | stable | heap</code> DEFAULT: <code>'stable'</code> </p> RETURNS DESCRIPTION <code>l</code> <p>The L-moment(s) of the input This is a scalar iff a is 1-d and r is a scalar. Otherwise, this is an array with <code>np.ndim(r) + np.ndim(a) - 1</code> dimensions and shape like <code>(*np.shape(r), *(d for d in np.shape(a) if d != axis))</code>.</p> <p> TYPE: <code>T | npt.NDArray[T]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).standard_normal(20)\n&gt;&gt;&gt; lmo.l_moment(x, [1, 2, 3, 4])\narray([0.00106117, 0.65354263, 0.01436636, 0.04280225])\n&gt;&gt;&gt; lmo.l_moment(x, [1, 2, 3, 4], trim=(1, 1))\narray([-0.0133052 ,  0.36644423, -0.00823471, -0.01034343])\n</code></pre> See Also <ul> <li>L-moment - Wikipedia</li> <li><code>scipy.stats.moment</code></li> </ul> References <ul> <li>J.R.M. Hosking (1990)</li> <li>E. Elmamir &amp; A. Seheult (2003) - Trimmed L-moments</li> <li>J.R.M. Hosking (2007) - Some theory and practical uses of trimmed     L-moments</li> </ul>"},{"location":"reference/#lmo.l_ratio","title":"<code>lmo.l_ratio(a, r, s, /, trim=(0, 0), axis=None, dtype=np.float_, **kwargs)</code>","text":"<p>Estimates the generalized L-moment ratio:</p> \\[ \\tau^{(t_1, t_2)}_{rs} = \\frac{     \\lambda^{(t_1, t_2)}_r }{     \\lambda^{(t_1, t_2)}_s } \\] <p>Equivalent to <code>lmo.l_moment(a, r, *, **) / lmo.l_moment(a, s, *, **)</code>.</p> Notes <p>The L-moment with <code>r=0</code> is <code>1</code>, so the <code>l_ratio(a, r, 0, *, **)</code> is equivalent to <code>l_moment(a, r, *, **)</code></p> <p>Examples:</p> <p>Estimate the L-location, L-scale, L-skewness and L-kurtosis simultaneously:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).lognormal(size=99)\n&gt;&gt;&gt; lmo.l_ratio(x, [1, 2, 3, 4], [0, 0, 2, 2])\narray([1.53196368, 0.77549561, 0.4463163 , 0.29752178])\n&gt;&gt;&gt; lmo.l_ratio(x, [1, 2, 3, 4], [0, 0, 2, 2], trim=(0, 1))\narray([0.75646807, 0.32203446, 0.23887609, 0.07917904])\n</code></pre> See Also <ul> <li><code>lmo.l_moment</code></li> </ul>"},{"location":"reference/#lmo.l_loc","title":"<code>lmo.l_loc(a, /, trim=(0, 0), axis=None, dtype=np.float_, **kwargs)</code>","text":"<p>L-location (or L-loc): unbiased estimator of the first L-moment, \\(\\lambda^{(t_1, t_2)}_1\\).</p> <p>Alias for <code>lmo.l_moment(a, 1, *, **)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).standard_cauchy(99)\n&gt;&gt;&gt; x.mean()\n-7.564850346291148\n&gt;&gt;&gt; lmo.l_loc(x)\n-7.56485034629115\n&gt;&gt;&gt; lmo.l_loc(x, trim=(1, 1))\n-0.1592418019341137\n</code></pre> Notes <p>If <code>trim = (0, 0)</code> (default), the L-location is equivalent to the arithmetic mean.</p> See Also <ul> <li><code>lmo.l_moment</code></li> <li><code>numpy.average</code></li> </ul>"},{"location":"reference/#lmo.l_scale","title":"<code>lmo.l_scale(a, /, trim=(0, 0), axis=None, dtype=np.float_, **kwargs)</code>","text":"<p>L-scale: unbiased estimator of the second L-moment, \\(\\lambda^{(t_1, t_2)}_2\\)</p> <p>Alias for <code>lmo.l_moment(a, 2, *, **)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).standard_cauchy(99)\n&gt;&gt;&gt; x.std()\n72.8771524453277\n&gt;&gt;&gt; lmo.l_scale(x)\n9.501123995203486\n&gt;&gt;&gt; lmo.l_scale(x, trim=(1, 1))\n0.6589932797072331\n</code></pre> Notes <p>If <code>trim = (0, 0)</code> (default), the L-scale is equivalent to half the Gini mean difference (GMD).</p> See Also <ul> <li><code>lmo.l_moment</code></li> <li><code>numpy.std</code></li> </ul>"},{"location":"reference/#lmo.l_variation","title":"<code>lmo.l_variation(a, /, trim=(0, 0), axis=None, dtype=np.float_, **kwargs)</code>","text":"<p>The coefficient of L-variation (or L-CV) unbiased sample estimator:</p> \\[ \\tau^{(t_1, t_2)} = \\frac{     \\lambda^{(t_1, t_2)}_2 }{     \\lambda^{(t_1, t_2)}_1 } \\] <p>Alias for <code>lmo.l_ratio(a, 2, 1, *, **)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).pareto(4.2, 99)\n&gt;&gt;&gt; x.std() / x.mean()\n1.321611129357151\n&gt;&gt;&gt; lmo.l_variation(x)\n0.5907363914181409\n&gt;&gt;&gt; lmo.l_variation(x, trim=(0, 1))\n0.5539504469144685\n</code></pre> Notes <p>If <code>trim = (0, 0)</code> (default), this is equivalent to the Gini coefficient, and lies within the interval \\((0, 1)\\).</p> See Also <ul> <li>Gini coefficient - Wikipedia</li> <li><code>lmo.l_ratio</code></li> <li><code>scipy.stats.variation.l_ratio</code></li> </ul>"},{"location":"reference/#lmo.l_skew","title":"<code>lmo.l_skew(a, /, trim=(0, 0), axis=None, dtype=np.float_, **kwargs)</code>","text":"<p>Unbiased sample estimator of the coefficient of L-skewness, or L-skew for short:</p> \\[ \\tau^{(t_1, t_2)}_3     = \\frac{         \\lambda^{(t_1, t_2)}_3     }{         \\lambda^{(t_1, t_2)}_2     } \\] <p>Alias for <code>lmo.l_ratio(a, 3, 2, *, **)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).standard_exponential(99)\n&gt;&gt;&gt; lmo.l_skew(x)\n0.38524343888616047\n&gt;&gt;&gt; lmo.l_skew(x, trim=(0, 1))\n0.2711613932338941\n</code></pre> See Also <ul> <li><code>lmo.l_ratio</code></li> <li><code>scipy.stats.skew</code></li> </ul>"},{"location":"reference/#lmo.l_kurtosis","title":"<code>lmo.l_kurtosis(a, /, trim=(0, 0), axis=None, dtype=np.float_, **kwargs)</code>","text":"<p>L-kurtosis coefficient; the 4th sample L-moment ratio.</p> \\[ \\tau^{(t_1, t_2)}_4     = \\frac{         \\lambda^{(t_1, t_2)}_4     }{         \\lambda^{(t_1, t_2)}_2     } \\] <p>Alias for <code>lmo.l_ratio(a, 4, 2, *, **)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; x = np.random.default_rng(12345).standard_t(2, 99)\n&gt;&gt;&gt; lmo.l_kurtosis(x)\n0.28912787109746096\n&gt;&gt;&gt; lmo.l_kurtosis(x, trim=(1, 1))\n0.19928182131774994\n</code></pre> Notes <p>The L-kurtosis \\(\\tau_4\\) lies within the interval \\([-\\frac{1}{4}, 1)\\), and by the L-skewness \\(\\tau_3\\) as \\(5 \\tau_3^2 - 1 \\le 4 \\tau_4\\).</p> See Also <ul> <li><code>lmo.l_ratio</code></li> <li><code>scipy.stats.kurtosis</code></li> </ul>"},{"location":"reference/#multivariate","title":"Multivariate","text":""},{"location":"reference/#lmo.l_comoment","title":"<code>lmo.l_comoment(a, r, /, trim=(0, 0), rowvar=True, dtype=np.float_, *, sort='stable')</code>","text":"<p>Multivariate extension of <code>lmo.l_moment</code>. Estimates the L-comoment matrix:</p> \\[ \\Lambda_{r}^{(t_1, t_2)} =     \\left[         \\lambda_{r [ij]}^{(t_1, t_2)}     \\right]_{m \\times m} \\] <p>Whereas the L-moments are calculated using the order statistics of the observations, i.e. by sorting, the L-comoment sorts \\(x_i\\) using the order of \\(x_j\\). This means that in general, \\(\\lambda_{r [ij]}^{(t_1, t_2)} \\neq \\lambda_{r [ji]}^{(t_1, t_2)}\\), i.e. \\(\\Lambda_{r}^{(t_1, t_2)}\\) is not symmetric.</p> <p>The \\(r\\)-th L-comoment \\(\\lambda_{r [ij]}^{(t_1, t_2)}\\) reduces to the L-moment if \\(i=j\\), and can therefore be seen as a generalization of the (univariate) L-moments. Similar to how the diagonal of a covariance matrix contains the variances, the diagonal of the L-comoment matrix contains the L-moments.</p> <p>Based on the proposed definition by Serfling &amp; Xiao (2007) for L-comoments. Extended to allow for generalized trimming.</p> PARAMETER DESCRIPTION <code>a</code> <p>1-D or 2-D array-like containing <code>m</code> variables and <code>n</code> observations. Each row of <code>a</code> represents a variable, and each column a single observation of all those variables. Also see <code>rowvar</code> below. If <code>a</code> is not an array, a conversion is attempted.</p> <p> TYPE: <code>npt.ArrayLike</code> </p> <code>r</code> <p>The L-moment order(s), non-negative integer or array.</p> <p> TYPE: <code>AnyInt | IntVector</code> </p> <code>trim</code> <p>Left- and right-trim orders \\((t_1, t_2)\\), non-negative integers that are bound by \\(t_1 + t_2 &lt; n - r\\).</p> <p>Some special cases include:</p> <ul> <li>\\((0, 0)\\): The original L-moment, introduced by Hosking (1990).     Useful for fitting the e.g. log-normal and generalized extreme     value (GEV) distributions.</li> <li>\\((0, m)\\): LL-moment (Linear combination of Lowest     order statistics), instroduced by Bayazit &amp; Onoz (2002).     Assigns more weight to smaller observations.</li> <li>\\((s, 0)\\): LH-moment (Linear combination of Higher     order statistics), by Wang (1997).     Assigns more weight to larger observations.</li> <li>\\((t, t)\\): TL-moment (Trimmed L-moment) \\(\\lambda_r^t\\),     with symmetric trimming. First introduced by     Elamir &amp; Seheult (2003).     Generally more robust than L-moments.     Useful for fitting heavy-tailed distributions, such as the     Cauchy distribution.</li> </ul> <p> TYPE: <code>tuple[int, int]</code> DEFAULT: <code>(0, 0)</code> </p> <code>rowvar</code> <p>If <code>rowvar</code> is True (default), then each row (axis 0) represents a variable, with observations in the columns (axis 1). Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dtype</code> <p>Floating type to use in computing the L-moments. Default is <code>numpy.float64</code>.</p> <p> TYPE: <code>np.dtype[T] | type[T]</code> DEFAULT: <code>np.float_</code> </p> <code>sort</code> <p>Sorting algorithm, see <code>numpy.sort</code>.</p> <p> TYPE: <code>quick | stable | heap</code> DEFAULT: <code>'stable'</code> </p> RETURNS DESCRIPTION <code>L</code> <p>Array of shape <code>(*r.shape, m, m)</code> with r-th L-comoments.</p> <p> TYPE: <code>npt.NDArray[T]</code> </p> <p>Examples:</p> <p>Estimation of the second L-comoment (the L-coscale) from biviariate normal samples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; rng = np.random.default_rng(12345)\n&gt;&gt;&gt; x = rng.multivariate_normal([0, 0], [[6, -3], [-3, 3.5]], 99).T\n&gt;&gt;&gt; lmo.l_comoment(x, 2)\narray([[ 1.2766793 , -0.83299947],\n       [-0.71547941,  1.05990727]])\n</code></pre> <p>The diagonal contains the univariate L-moments:</p> <pre><code>&gt;&gt;&gt; lmo.l_moment(x, 2, axis=-1)\narray([1.2766793 , 1.05990727])\n</code></pre> References <ul> <li>R. Serfling &amp; P. Xiao (2007) - A Contribution to Multivariate     L-Moments: L-Comoment Matrices</li> </ul>"},{"location":"reference/#lmo.l_coratio","title":"<code>lmo.l_coratio(a, r, s, /, trim=(0, 0), rowvar=True, dtype=np.float_, **kwargs)</code>","text":"<p>Estimate the generalized matrix of L-comoment ratio's:</p> \\[ \\tilde \\Lambda_{rs}^{(t_1, t_2)} =     \\left[         \\left. \\lambda_{r [ij]}^{(t_1, t_2)} \\right/         \\lambda_{s [jj]}^{(t_1, t_2)}     \\right]_{m \\times m} \\] See Also <ul> <li><code>lmo.l_comoment</code></li> <li><code>lmo.l_ratio</code></li> </ul>"},{"location":"reference/#lmo.l_coloc","title":"<code>lmo.l_coloc(a, /, trim=(0, 0), rowvar=True, dtype=np.float_, **kwargs)</code>","text":"<p>L-colocation matrix of 1st L-comoment estimates, \\(\\Lambda^{(t_1, t_2)}_1\\).</p> <p>Alias for <code>lmo.l_comoment(a, 1, *, **)</code>.</p> Notes <p>If <code>trim = (0, 0)</code> (default), the L-colocation for \\([ij]\\) is the L-location \\(\\lambda_1\\) of \\(x_i\\), independent of \\(x_j\\).</p> <p>Examples:</p> <p>Without trimming, the L-colocation only provides marginal information:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; rng = np.random.default_rng(12345)\n&gt;&gt;&gt; x = rng.multivariate_normal([0, 0], [[6, -3], [-3, 3.5]], 99).T\n&gt;&gt;&gt; lmo.l_loc(x, axis=-1)\narray([-0.02678225,  0.03008309])\n&gt;&gt;&gt; lmo.l_coloc(x)\narray([[-0.02678225, -0.02678225],\n       [ 0.03008309,  0.03008309]])\n</code></pre> <p>But the trimmed L-locations are a different story...</p> <pre><code>&gt;&gt;&gt; lmo.l_loc(x, trim=(1, 1), axis=-1)\narray([-0.10488868, -0.00625729])\n&gt;&gt;&gt; lmo.l_coloc(x, trim=(1, 1))\narray([[-0.10488868, -0.03797989],\n       [ 0.03325074, -0.00625729]])\n</code></pre> <p>What this tells us, is somehwat of a mystery: trimmed L-comoments have been only been briefly mentioned once or twice in the literature.</p> See Also <ul> <li><code>lmo.l_comoment</code></li> <li><code>lmo.l_loc</code></li> <li><code>numpy.mean</code></li> </ul>"},{"location":"reference/#lmo.l_coscale","title":"<code>lmo.l_coscale(a, /, trim=(0, 0), rowvar=True, dtype=np.float_, **kwargs)</code>","text":"<p>L-coscale matrix of 2nd L-comoment estimates, \\(\\Lambda^{(t_1, t_2)}_2\\).</p> <p>Alias for <code>lmo.l_comoment(a, 2, *, **)</code>.</p> <p>Analogous to the (auto-) variance-covariance matrix, the L-coscale matrix is positive semi-definite, and its main diagonal contains the L-scale's. conversely, the L-coscale matrix is inherently assymmetric, thus yielding more information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; rng = np.random.default_rng(12345)\n&gt;&gt;&gt; x = rng.multivariate_normal([0, 0], [[6, -3], [-3, 3.5]], 99).T\n&gt;&gt;&gt; lmo.l_scale(x, trim=(1, 1), axis=-1)\narray([0.66698774, 0.54440895])\n&gt;&gt;&gt; lmo.l_coscale(x, trim=(1, 1))\narray([[ 0.66698774, -0.41025416],\n       [-0.37918065,  0.54440895]])\n</code></pre> See Also <ul> <li><code>lmo.l_comoment</code></li> <li><code>lmo.l_scale</code></li> <li><code>numpy.cov</code></li> </ul>"},{"location":"reference/#lmo.l_corr","title":"<code>lmo.l_corr(a, /, trim=(0, 0), rowvar=True, dtype=np.float_, **kwargs)</code>","text":"<p>Sample L-correlation coefficient matrix \\(\\tilde\\Lambda^{(t_1, t_2)}_2\\); the ratio of the L-coscale matrix over the L-scale column-vectors.</p> <p>Alias for <code>lmo.l_coratio(a, 2, 2, *, **)</code>.</p> <p>The diagonal consists of all 1's.</p> <p>Where the pearson correlation coefficient measures linearity, the (T)L-correlation coefficient measures monotonicity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import lmo, numpy as np\n&gt;&gt;&gt; rng = np.random.default_rng(12345)\n&gt;&gt;&gt; cov = np.array([[6, -3], [-3, 3.5]])\n&gt;&gt;&gt; x = rng.multivariate_normal([0, 0], [[6, -3], [-3, 3.5]], 99).T\n&gt;&gt;&gt; lmo.l_corr(x)\narray([[ 1.        , -0.65247355],\n       [-0.67503962,  1.        ]])\n</code></pre> <p>Let's compare this with the theoretical correlation</p> <pre><code>&gt;&gt;&gt; cov[0, 1] / np.sqrt(cov[0, 0] * cov[1, 1])\n-0.6546536707079772\n</code></pre> <p>and the (Pearson) correlation coefficient matrix:</p> <pre><code>&gt;&gt;&gt; np.corrcoef(x)\narray([[ 1.        , -0.66383285],\n       [-0.66383285,  1.        ]])\n</code></pre> See Also <ul> <li><code>lmo.l_coratio</code></li> <li><code>numpy.corrcoef</code></li> </ul>"},{"location":"reference/#lmo.l_coskew","title":"<code>lmo.l_coskew(a, /, trim=(0, 0), rowvar=True, dtype=np.float_, **kwargs)</code>","text":"<p>Sample L-coskewness coefficient matrix \\(\\tilde\\Lambda^{(t_1, t_2)}_3\\).</p> <p>Alias for <code>lmo.l_coratio(a, 3, 2, *, **)</code>.</p> See Also <ul> <li><code>lmo.l_coratio</code></li> <li><code>lmo.l_skew</code></li> </ul>"},{"location":"reference/#lmo.l_cokurtosis","title":"<code>lmo.l_cokurtosis(a, /, trim=(0, 0), rowvar=True, dtype=np.float_, **kwargs)</code>","text":"<p>Sample L-cokurtosis coefficient matrix \\(\\tilde\\Lambda^{(t_1, t_2)}_4\\).</p> <p>Alias for <code>lmo.l_coratio(a, 4, 2, *, **)</code>.</p> See Also <ul> <li><code>lmo.l_coratio</code></li> <li><code>lmo.l_kurtosis</code></li> </ul>"}]}